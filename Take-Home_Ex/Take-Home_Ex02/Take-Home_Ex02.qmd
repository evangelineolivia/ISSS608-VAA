---
title: "Take Home Exercise 2"
description: VAST Challenge 2025 Mini-Challenge 1
date: 2025-05-13
date-modified: "last-modified"
execute:
  warning: false
  freeze: true
format: 
  html:
    number-offset: 0
---
# Overview

For this take-home exercise, we will be working on **Mini-Challenge 1** from the [**VAST Challenge 2025**](https://vast-challenge.github.io/2025/index.html). The objective of this exercise is to design visual analytics methods to track the emergence of a rising artist and forecast the next potential breakout star.

We will address the questions from the mini-challenge specifically **Question 3**:

## The Profile of Sailor Shift's Career :

-   Who has Sailor Shift been most influenced by over time?
-   Who has she collaborated with and directly or indirectly influenced?
-   How has she influenced collaborators within the broader **Oceanus Folk** community?

## The Influence of Oceantus Folk to the Music World :

-   Was this influence **intermittent** or did it show a **gradual rise**?
-   What **genres** and **top artists** have been most influenced by Oceanus Folk?
-   On the conveerse, how has Oceantus Folk changed the rise of Sailor Shift? From which **genre** does it draw most of its contemporary inspiration?

## **Profile of What it Means to be a Rising Star in the Music Industry**

-   Visualize the careers of **3 Artist**
-   Compare and Contrast their rise in **Popularity** and **Influence**
-   Using this characterization, gives **3 Predictions** of the next Oceanus Folk stars with be over the next **5 Years**

# The Data

We will use the dataset provided in the VAST Challenge 2025 Mini-Challenge 1.

::: {.panel-tabset .nav-pills}
#### File Overview

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'
#| code-fold: true

library(knitr)
library(tibble)

dataset_info <- tibble(
  Attribute = c("File Name", "Graph Type", "Number of Nodes", "Number of Edges", "Connected Components"),
  Value = c("MC1_graph.json", "Directed Multigraph", "17,412", "37,857", "18")
)

kable(dataset_info)
```

#### Node

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'
#| code-fold: true
node <- tibble(
  Node_Type = c("Person", "Song", "RecordLabel", "Album", "MusicalGroup")
)

kable(node)
```

#### Edge

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: 'asis'
#| code-fold: true
edge <- tibble(
  Edge_Type = c(
    "PerformerOf", "ComposerOf", "ProducerOf", "LyricistOf", "RecordedBy",
    "DistributedBy", "InStyleOf", "InterpolatesFrom", "CoverOf",
    "LyricalReferenceTo", "DirectlySamples", "MemberOf"
  ),
  Description = c(
    "Source (Person or Group) performed the destination (Song or Album)",
    "Source (Person) composed the destination (Song or Album)",
    "Source (Person or Label) produced the destination's work (Song, Album, Person, or Group)",
    "Source (Person) wrote lyrics for the destination (Song or Album)",
    "Destination (Label) recorded the source (Song or Album)",
    "Destination (Label) distributed the source (Song or Album)",
    "Source (Song/Album) is in the style of the destination (Song, Album, Person, or Group)",
    "Source (Song/Album) interpolates melody from the destination (Song or Album)",
    "Source (Song/Album) is a cover of the destination (Song or Album)",
    "Source (Song/Album) makes lyrical reference to the destination (Song or Album)",
    "Source (Song/Album) directly samples audio from the destination (Song or Album)",
    "Source (Person) is a member of the destination (MusicalGroup)"
  )
)

kable(edge)
```
:::

# Setting Up

## Loading Packages

::: {.panel-tabset .nav-pills}
#### Packages

```{r}
pacman::p_load(tidyverse, jsonlite,
               tidygraph, ggraph, igraph, plotly, visNetwork,ggtext, ggiraph,patchwork, kableExtra, showtext)
```

#### Packages Information

| **Library** | **Description** |
|-------------|------------------|
| `pacman` | A package management tool that simplifies the process of installing, loading, and managing R packages with a single function. Ideal for scripts requiring multiple libraries. |
| `tidyverse` | A cohesive collection of R packages for data science, including `ggplot2`, `dplyr`, `tidyr`, `readr`, and more—providing consistent grammar for data wrangling and visualization. |
| `jsonlite` | A fast and flexible JSON parser/serializer, useful for importing and exporting structured data such as API responses or configuration files. |
| `tidygraph` | A tidyverse-friendly package for network data manipulation and analysis, built on top of `igraph`. Enables graph operations using `dplyr`-like syntax. |
| `ggraph` | An extension of `ggplot2` for visualizing graph/network data using layered grammar of graphics principles. Works seamlessly with `tidygraph`. |
| `igraph` | A powerful low-level package for network analysis and visualization, supporting complex graph structures, centrality metrics, and community detection. |
| `plotly` | Enables creation of interactive plots from `ggplot2` or native `plotly` syntax. Useful for dashboards, exploratory data analysis, and web-based visualizations. |
| `visNetwork` | Creates rich, interactive network visualizations using `vis.js`. Highly customizable and ideal for interactive dashboards and exploratory analysis. |
| `ggtext` | Enhances `ggplot2` by allowing Markdown/HTML formatting in axis labels, legends, titles, and more—perfect for expressive visual storytelling. |
| `ggiraph` | Adds interactivity (tooltips, hover effects, hyperlinks) to `ggplot2` graphics. Useful for embedding interactive plots in Shiny apps or HTML reports. |
| `patchwork` | Simplifies the combination of multiple `ggplot2` plots into a single layout using intuitive arithmetic-like syntax. Great for dashboards or multi-panel displays. |
| `kableExtra` | Extends `knitr::kable()` to create professional-looking tables in HTML, LaTeX, or Word with styling, column grouping, footnotes, and more. |
| `showtext` | Makes it easy to use custom fonts in R plots, including Chinese, Japanese, and Korean fonts—ideal for multilingual data visualization. |
:::

::: scroll-output
## Loading Data

```{r}
data <- fromJSON("data/MC1_graph.json")
glimpse(data)
```
:::

## Custom Style

::: {.panel-tabset .nav-pills}
### Colors

```{r}
cl <- list(
  bg = "#FEFCF3",
  t_shirt = "#7B3F00",
  sweater = "#D7A18F",
  jeans = "#D9C6B0",
  title = "#2F3A3F",
  background = "#F8F1E5",
  text = "#B1A293",
  
  #Nodes
  Person = "#D5D1E9",       
  MusicalGroup = "#D0E4EE",  
  RecordLabel = "#F3F5A9",   
  Song = "#F5CF9F",          
  Album = "#F28B82",
  
  #Edges
  PerformerOf         = "#e6194b",  
  ComposerOf          = "#f58231",  
  ProducerOf          = "#ffe119",  
  LyricistOf          = "#3cb44b",  
  RecordedBy          = "#42d4f4",  
  DistributedBy       = "#4363d8",  
  InStyleOf           = "#911eb4",  
  InterpolatesFrom    = "#f032e6",  
  CoverOf             = "#fabebe",  
  LyricalReferenceTo  = "#ffd8b1",  
  DirectlySamples     = "#fffac8", 
  MemberOf            = "#4A7365"   
)
```

### Theme

```{r}
font_add_google("Montserrat", "montserrat")
showtext_auto()
theme <- list(
  font = 'montserrat',
  size=14,
  background = element_rect(fill = cl$bg,color = NA),
  title = element_text(
      size = 16,
      face = "bold",
      color = "black"),
  fill = cl$text,
  panel = element_rect(fill = cl$bg, color = NA),
  grid = element_line(color = "#E6DCD0"),
  
  #Text 
  caption = "Hover on the nodes to see more details.",
  
  #Node
  node_size = 7.5,
  arrow_margin = 3.2,
  arrow_style = arrow(type = "closed", length = unit(2, "pt")),
  base_edge_thickness = 0.2,
  
  tooltip = "background-color: #E6DCD0;
  color: #2F3A3F;
  border: 1px solid #e0d7ec;
  border-radius: 6px;
  padding: 6px;
  font-size: 12px;
  box-shadow: 1px 1px 4px rgba(0,0,0,0.1);
  "
)
```
:::

# Data Preparation

## Extracting

::: {.panel-tabset .nav-pills}
### Edges

```{r}
edges <- as_tibble(data$links)
edge
```

### Nodes

```{r}
nodes <- as_tibble(data$nodes)
nodes
```
:::

```{r}
colnames(nodes)[colnames(nodes) == "Node Type"] <- "type"
colnames(edges)[colnames(edges) == "Edge Type"] <- "relation"
```

## Check Missing Values

::: {.panel-tabset .nav-pills}
### Edges

```{r}
colSums(is.na(edges))
```

### Nodes

```{r}
colSums(is.na(nodes))
```
:::

## Check for Duplicates

::: {.panel-tabset .nav-pills}
### Edges

```{r}
edges[duplicated(edges),]
```

### Nodes

```{r}
nodes[duplicated(nodes),]
```
:::

# Knowledge Graph

## Mapping from node id to row index

```{r}
id_map <- tibble(id = nodes$id,
                 index = seq_len(
                   nrow(nodes)))
```

## Map source and target IDs to row indices

```{r}
edges <- edges %>%
  left_join(id_map, by = c("source" = "id")) %>%
  rename(from = index) %>%
  left_join(id_map, by = c("target" = "id")) %>%
  rename(to = index)
```

## Filtering out unmatched edges

```{r}
edges <- edges %>%
  filter(!is.na(from), !is.na(to))
```

## Plotting the Whole Graph

```{r}
graph <- tbl_graph(nodes = nodes, edges = edges, directed = data$directed)

graph <- graph %>%
  activate(nodes) %>%
  mutate(`Node Type` = factor(type, levels = names(cl)))
```

# Exploratory Data Analysis

::: {.panel-tabset .nav-pills}
## Distribution of Edge Type

```{r}
#| code-fold: true
ggplot(data = edges,
       aes(y = relation)) +
  geom_bar(fill = theme$fill) +
  labs(title="Distribution of Edge Type") +
  theme_classic() +
  theme(plot.background = theme$background,
        panel.background = theme$panel,
        panel.grid.major = theme$grid,
        text = element_text(family = theme$font,
                            size = theme$size),
        plot.title = theme$title)
```

## Distribution of Node Type

```{r}
#| code-fold: true
ggplot(data = nodes,
       aes(y = type)) +
  geom_bar(fill = theme$fill) +
  labs(title="Distribution of Node Type") +
  theme_classic() +
  theme(plot.background = theme$background,
        panel.background = theme$panel,
        panel.grid.major = theme$grid,
        text = element_text(family = theme$font,
                            size = theme$size),
        plot.title = theme$title)
```
:::

## Understanding the Most Connected Nodes

```{r}
#| code-fold: true
graph %>%
  activate(nodes) %>%
  mutate(degree = centrality_degree()) %>%
  as_tibble() %>%
  arrange(desc(degree)) %>%
  slice_head(n = 10) %>%
  ggplot(aes(x = reorder(name, degree), 
             y = degree, 
             fill = `Node Type`)) +
  geom_col() +
  geom_text(aes(label = degree), 
            hjust = -0.2, 
            size = 4, 
            family = theme$font) +
  coord_flip() +
  labs(title = "Top 10 Most Connected Nodes", x = "Name", y = "Degree") + 
  scale_fill_manual(values = cl
  ) +
  theme_classic() +
  theme(
    plot.background = theme$background,
    panel.background = theme$panel,
    panel.grid.major = theme$grid,
    text = element_text(family = theme$font, size = theme$size),
    plot.title = theme$title
  )
```

::: {.callout-tip collapse="true"}
### Observations

-   **Degree** is a measure in network analysis that represents the number of direct connections a node has to other nodes.

-   Here I plot **Top 10 Most Connected Nodes Plot** to quickly see the key collaborators and influencers based on their direct connections within the community.
:::

## Top Genres

```{r}
#| code-fold: true
nodes %>%
  filter(!is.na(genre)) %>%
  count(genre, sort = TRUE) %>%
  slice_max(n, n = 10) %>%
  ggplot(aes(x = reorder(genre, n), y = n, fill = n)) +
  geom_col() +
  scale_fill_gradient(low = cl$jeans, high = cl$text) +
  coord_flip() +
  labs(title = "Top 10 Genres", x = "Genre", y = "Count") +
  theme_classic() +
  theme(plot.background = theme$background,
        panel.background = theme$panel,
        panel.grid.major = theme$grid,
        text = element_text(family = theme$font,
                            size = theme$size),
        plot.title = theme$title)
```

::: {.callout-tip collapse="true"}
### Observations

-   **Oceanus Folk** is among the top genres which align with the narrative that Sailor Shift's rise helped the Oceanus Folk genre into the mainstream music genres.

-   **Dream Pop, Indie Folk, and Synthwave** are the most represented genres in the dataset.
:::

# Plotting Sub-Graphs

In this part, I will create several subnetworks to explore different perspectives within the dataset.

```{r}
#| code-fold: true
plot<- function(graph, center_name, title, size_1, size_2, show_arrows = TRUE, layout = "fr") {
  
  set.seed(123)

  V(graph)$type <- trimws(as.character(V(graph)$type))
  E(graph)$relation <- trimws(as.character(E(graph)$relation))
  V(graph)$name <- gsub("'", "`", V(graph)$name)
  V(graph)$is_center <- V(graph)$name == center_name
  V(graph)$tooltip <- paste0(
  "Name: ", V(graph)$name, "\n",
  "Type: ", V(graph)$type)
  V(graph)$node_size <- degree(graph)
  V(graph)$node_size <- scales::rescale(degree(graph), to = c(size_1, size_2))

  node_colors <- cl[names(cl) %in% unique(V(graph)$type)]
  edge_colors <- unlist(cl[names(cl) %in% unique(E(graph)$relation)])
  
  edge_layer <- if (show_arrows) {
  geom_edge_link(
    aes(edge_colour = relation),
    arrow = arrow(length = unit(1.5, "mm"), type = "closed"),
    end_cap = circle(0.5, "mm"),
    start_cap = circle(0.5, "mm"),
    width = 0.3,
    alpha = 0.7
  )
} else {
  geom_edge_link(
    aes(edge_colour = relation),
    end_cap = circle(0.5, "mm"),
    start_cap = circle(0.5, "mm"),
    width = 0.3,
    alpha = 0.7
  )
}

  g<-ggraph(graph, layout = layout) +
    edge_layer +
    geom_edge_link(
  aes(color = relation),
  arrow = if (show_arrows) arrow(length = unit(1.5, "mm"), type = "closed") else NULL,
  end_cap = circle(0.5, "mm"),
  start_cap = circle(0.5, "mm"),
  width = 0.3,
  alpha = 0.7)+
    geom_point_interactive(aes(
      x = x, y = y,
      fill = as.character(type),
      tooltip = tooltip,
      data_id = name,
      size = node_size,
      stroke = ifelse(is_center, 1, 0.15)
    ),
    shape = 21
  ) +
    scale_size_identity()+
    geom_node_text(
  aes(label = ifelse(is_center, name, "")),
  nudge_y = 0.1, 
  nudge_x = -0.2, 
  repel = TRUE,
  size = 3,
  color = "black"
  )+
    theme_minimal() +
    labs(title = title,
         caption = "Hover to view details") +
    scale_fill_manual(values = node_colors, name = "Node Type") +
    scale_edge_colour_manual(values = edge_colors, name = "Edge Type") +
    theme_minimal() +
    theme(
      panel.border = element_rect(color = "black", fill = NA, size = 0.5),
      axis.title = element_blank(),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      plot.background = element_rect(fill = "#FEFCF3", color = NA),
      plot.title = element_text(color = cl$title, size = 14, face = "bold"),
      plot.caption = element_text(hjust = 0, size = 8,face = "bold", margin = margin(t = 10),color = cl$title),
      legend.text = element_text(size = 9),      
      legend.title = element_text(size = 10),     
      legend.key.size = unit(0.5, "lines"),       
      legend.spacing.y = unit(2, "pt")            
    )
  girafe(ggobj = g,
         options = list(opts_tooltip(css = theme$tooltip)))
}
```

## Functions

[<strong>Ego</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
ego_subgraph <- function(graph, center_name) {
  graph %>%
    activate(nodes) %>%
    mutate(is_target = name == center_name) %>%
    convert(to_subgraph, node_is_adjacent(which(is_target)) | is_target)
}
```

[<strong>Genre</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
get_oceanusfolk_subgraph <- function(graph, genre_name = "Oceanus Folk", relation_type = "PerformerOf") {
  oceanus_songs <- V(graph)[type == "Song" & genre == genre_name]
  performer_edges <- E(graph)[relation == relation_type & .inc(oceanus_songs)]
  connected_nodes <- unique(as.vector(ends(graph, performer_edges)))
  temp_subgraph <- induced_subgraph(graph, V(graph)[name %in% connected_nodes])
  subgraph.edges(temp_subgraph, E(temp_subgraph)[relation == relation_type])
}
```

## Sailor Shift Ego Network

```{r}
#| code-fold: true
sailor_ego <- ego_subgraph(graph, "Sailor Shift")
plot(sailor_ego,"Sailor Shift","Ego Network of Sailor Shift",3,5)
```

## Oceanus Folk Sub Graph

```{r}
#| code-fold: true
oceanusfolk_subgraph <- get_oceanusfolk_subgraph(graph)
plot(oceanusfolk_subgraph, center_name = "", title = "Oceanus Folk Songs",1,2,FALSE)
```

# Mini Challenge

## Question 3 : Visualize the careers of three artists

To ensure genre-relevant comparisons, I limited my analysis to artists connected to the Oceanus Folk community through performer or stylistic influence links.

To have a data driven definition of a rising star within Oceanus Folk music industry, I begin by examining the career of Sailor Shift. Her rise in popularity provides a benchmark for identifying the key traits and network patterns that characterize emerging breakout artists in this genre.

To identify rising stars in the Oceanus Folk genre, I propose the following set of metrics based on network structure and artist activity:

### Defining Key Metrics

```{r echo = FALSE}
rising_star_metrics <- tibble(
  Trait = c(
    "Creative Activity",
    "Creative Contribution",
    "Collaboration",
    "Public Recognition"
  ),
  `Measured By` = c(
    "Songs & Album released over time",
    "ComposerOf, LyricistOf, ProducerOf edges",
    "Any other person who is connected to the same song(s) as the artist via a creative roles",
    "Number of notable releases over time"
  )
)

kable(rising_star_metrics, caption = "Rising Star Profile Metrics")
```

### Functions

[<strong>Plot</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
plot <- function(graph, center_name, title, size_1, size_2, show_arrows = TRUE, layout = "fr") {
  set.seed(123)

  V(graph)$type       <- trimws(as.character(V(graph)$type))
  V(graph)$name       <- gsub("'", "`", V(graph)$name)
  V(graph)$is_center  <- V(graph)$name == center_name
  V(graph)$tooltip    <- paste0("Name: ", V(graph)$name, "\nYear: ", V(graph)$release_date)
  V(graph)$node_size  <- scales::rescale(degree(graph), to = c(size_1, size_2))

  E(graph)$relation   <- trimws(as.character(E(graph)$relation))

  node_colors <- cl[names(cl) %in% unique(V(graph)$type)]
  edge_colors <- unlist(cl[names(cl) %in% unique(E(graph)$relation)])

  g <- ggraph(graph, layout = layout) +
    geom_edge_link(
      aes(edge_colour = relation),
      arrow     = if (show_arrows) arrow(length = unit(3, "mm"), type = "closed") else NULL,
      end_cap   = circle(0.5, "mm"),
      start_cap = circle(0.5, "mm"),
      width     = 0.3,
      alpha     = 0.7
    ) +
    scale_edge_colour_manual(values = edge_colors, name = "Edge Type") +
    
    geom_point_interactive(
      aes(
        x = x, y = y,
        fill     = as.character(type),
        tooltip  = tooltip,
        data_id  = name,
        size     = node_size,
        stroke   = ifelse(is_center, 1, 0.15)
      ),
      shape = 21
    ) +
    scale_size_identity() +

    geom_node_text(
      aes(label = ifelse(is_center, name, "")),
      nudge_y = 0.5, 
      nudge_x = 0.2,
      repel   = TRUE,
      size    = 4,
      color   = "black"
    ) +

    labs(
      title   = title,
      caption = "Hover to view node's details"
    ) +
    scale_fill_manual(values = node_colors, name = "Node Type") +
    theme_minimal() +
    theme(
      panel.border      = element_rect(color = "black", fill = NA, size = 0.5),
      axis.title        = element_blank(),
      axis.text         = element_blank(),
      axis.ticks        = element_blank(),
      panel.grid        = element_blank(),
      plot.background   = element_rect(fill = "#FEFCF3", color = NA),
      plot.title        = element_text(color = cl$title, size = 14, face = "bold"),
      plot.caption      = element_text(hjust = 0, size = 8, face = "bold", 
                                       margin = margin(t = 10), color = cl$title),
      legend.text       = element_text(size = 9),
      legend.title      = element_text(size = 10),
      legend.key.size   = unit(0.5, "lines"),
      legend.spacing.y  = unit(2, "pt")
    )

  girafe(
    ggobj   = g,
    options = list(opts_tooltip(css = theme$tooltip))
  )
}
```

[<strong>Clean Duplicates</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
clean_duplicate_artist <- function(graph, artist_name) {

  igraph <- as.igraph(graph)

  node_ids <- which(V(igraph)$name == artist_name)

  if (length(node_ids) > 1) {
    main_node <- node_ids[1]
    dup_nodes <- node_ids[-1]

    for (dup in dup_nodes) {
      inc_edges <- incident(igraph, dup, mode = "all")

      for (e in inc_edges) {
        ends_ids <- ends(igraph, e, names = FALSE)

        from_id <- ends_ids[1]
        to_id   <- ends_ids[2]

        if (from_id == dup) from_id <- main_node
        if (to_id == dup) to_id <- main_node

        if (from_id != to_id) {
          edge_attrs <- edge.attributes(igraph, e)

          igraph <- add_edges(igraph, c(from_id, to_id))
          new_edge_id <- ecount(igraph)

          for (attr_name in names(edge_attrs)) {
            edge_attr(igraph, attr_name, index = new_edge_id) <- edge_attrs[[attr_name]]
          }
        }
      }
    }

    igraph <- delete_vertices(igraph, dup_nodes)
  }

  return(as_tbl_graph(igraph))
}
```

[<strong>Creative Activity</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
artist_creativity <- function(graph, artist_name) {

  artist_index <- graph %>%
    activate(nodes) %>%
    mutate(index = row_number()) %>%
    filter(name == artist_name) %>%
    pull(index)

  member_of_groups <- graph %>%
    activate(edges) %>%
    filter(from == artist_index, relation == "MemberOf") %>%
    pull(to)

  group_names <- character()
  group_indices <- integer()

  if (length(member_of_groups) > 0) {
    group_names <- graph %>%
      activate(nodes) %>%
      mutate(index = row_number()) %>%
      filter(index %in% member_of_groups) %>%
      pull(name)

    group_indices <- graph %>%
      activate(nodes) %>%
      mutate(index = row_number()) %>%
      filter(name %in% group_names) %>%
      pull(index)
  }

  performer_ids <- c(artist_index, group_indices)

  performed_ids <- graph %>%
    activate(edges) %>%
    filter(relation == "PerformerOf", from %in% performer_ids) %>%
    pull(to)

  performed_works <- graph %>%
    activate(nodes) %>%
    mutate(index = row_number()) %>%
    filter(index %in% performed_ids,
           (type == "Song" & single == TRUE & !is.na(single)) | type == "Album") %>%
    select(name, release_date, type, index) %>%
    arrange(release_date) %>%
    as_tibble()

  subgraph_indices <- unique(c(artist_index, group_indices, performed_works$index))

  subgraph <- induced_subgraph(graph, vids = subgraph_indices) %>%
    as_tbl_graph() %>%
    activate(edges) %>%
    filter(relation %in% c("PerformerOf", "MemberOf")) %>%
    activate(nodes) %>%
    mutate(label = case_when(
      type == "Song" ~ paste0(name, " (", release_date, ")"),
      type == "Album" ~ paste0("[Album] ", name, " (", release_date, ")"),
      TRUE ~ name
    ))

  return(list(
    graph = subgraph,
    works = performed_works %>% select(name, type, release_date),
    group = group_names
  ))
}
```

```{r}
#| code-fold: true
release_timeline <- function(song_years, artist_name = "Artist") {

  release_counts <- song_years %>%
    filter(type %in% c("Song", "Album")) %>%
    mutate(release_year = as.integer(release_date)) %>%
    count(release_year)

  ggplot(release_counts, aes(x = release_year, y = n)) +
    geom_line(color = cl$jeans, linewidth = 1.2) +
    geom_point(color = cl$t_shirt, size = 2) +
    labs(
      title = paste0(artist_name, "'s Songs or Albums Release Timeline"),
      x = "Year",
      y = "Number of Releases"
    ) +
    scale_x_continuous(breaks = seq(min(release_counts$release_year),
                                    max(release_counts$release_year), by = 1)) +
    scale_y_continuous(breaks = seq(0, max(release_counts$n), by = 1)) +
    theme_classic() +
    theme(
      plot.background = theme$background,
      panel.background = theme$panel,
      panel.grid.major = theme$grid,
      text = element_text(family = theme$font, size = theme$size),
      plot.title = theme$title,
      axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
    )
}
```

[<strong>Creative Contribution</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
contribution_network <- function(graph, artist_name) {

  artist_id <- graph %>%
    activate(nodes) %>%
    mutate(index = row_number()) %>%
    filter(name == artist_name) %>%
    pull(index)

  creative_edges <- graph %>%
    activate(edges) %>%
    filter(from == artist_id, relation %in% c("ComposerOf", "LyricistOf", "ProducerOf")) %>%
    as_tibble()

  node_info <- graph %>%
  activate(nodes) %>%
  mutate(index = row_number()) %>%
  as_tibble()  

  creative_edges <- creative_edges %>%
    left_join(node_info %>% select(index, name, release_date, type) %>%
              mutate(release_year = as.integer(release_date)),
            by = c("to" = "index"))

  song_ids <- creative_edges$to
  subgraph_indices <- unique(c(artist_id, song_ids))

  subgraph <- induced_subgraph(graph, vids = subgraph_indices) %>%
    as_tbl_graph() %>%
    activate(edges) %>%
    filter(relation %in% c("ComposerOf", "LyricistOf", "ProducerOf")) %>%
    activate(nodes) %>%
    mutate(
      label = paste0(name, " (", release_date, ")")
    )

  song_data <- creative_edges %>%
    select(name, relation, release_date, release_year) %>%
    arrange(release_date)

  return(list(graph = subgraph, song_data = song_data))
}
```

[<strong>Artist Collaborators</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
artist_collab_network <- function(graph, artist_name) {
  collab_roles <- c("PerformerOf", "ComposerOf", "LyricistOf", "ProducerOf")
  
  artist_index <- graph %>%
    activate(nodes) %>%
    mutate(index = row_number()) %>%
    filter(name == artist_name) %>%
    pull(index)
  
  artist_songs <- graph %>%
    activate(edges) %>%
    filter(from == artist_index, relation %in% collab_roles) %>%
    pull(to)
  
  collab_edges <- graph %>%
    activate(edges) %>%
    filter(to %in% artist_songs, relation %in% collab_roles) %>%
    filter(from != artist_index) %>%
    as_tibble()
  
  collab_node_ids <- unique(c(artist_index, collab_edges$from, collab_edges$to))
  
  subgraph <- graph %>%
  as.igraph() %>%
  induced_subgraph(vids = collab_node_ids) %>%
  as_tbl_graph() %>%
  activate(edges) %>%
  filter(relation %in% collab_roles) %>%          
  activate(nodes) %>%
  mutate(label = case_when(
    `Node Type` == "Song" ~ paste0(name, " (", release_date, ")"),
    TRUE ~ name
  ))
  
  return(subgraph)
}
```

[<strong>Public Recognition</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
public_recognition_table <- function(graph, artist_name) {
  artist_id <- graph %>%
    activate(nodes) %>%
    mutate(row_id = row_number()) %>%
    filter(name == artist_name) %>%
    pull(row_id)

  group_ids <- graph %>%
    activate(edges) %>%
    filter(from == artist_id, relation == "MemberOf") %>%
    pull(to)

  performer_ids <- if (length(group_ids) > 0) c(artist_id, group_ids) else artist_id

  performer_edges <- graph %>%
    activate(edges) %>%
    filter(from %in% performer_ids, relation == "PerformerOf") %>%
    as_tibble() %>%
    mutate(Performer = ifelse(from == artist_id, "Solo", "Group"))

  node_df <- graph %>%
    activate(nodes) %>%
    as_tibble() %>%
    mutate(row_id = row_number())

  charted <- performer_edges %>%
    left_join(node_df, by = c("to" = "row_id")) %>%
    filter(type %in% c("Song", "Album"), notable == TRUE) %>%
    filter(type != "Song" | single == TRUE) %>%
    transmute(
      Title = name,
      Type = type,
      Performer,
      `Release Year` = release_date
    )

  solo <- charted %>%
    filter(Performer == "Solo") %>%
    bind_rows(tibble(
      Title = "Total",
      Type = "",
      Performer = "",
      `Release Year` = as.character(nrow(.))
    ))

  group <- charted %>%
    filter(Performer == "Group") %>%
    bind_rows(tibble(
      Title = "Total",
      Type = "",
      Performer = "",
      `Release Year` = as.character(nrow(.))
    ))

  return(list(Solo = solo, Group = group))
}
```

```{r}
#| code-fold: true
public_recognition_line <- function(graph, artist_name = "Sailor Shift") {
  artist_id <- graph %>% 
    activate(nodes) %>% mutate(row_id = row_number()) %>% filter(name == artist_name) %>% pull(row_id)
  group_ids <- graph %>% activate(edges) %>% filter(from == artist_id, relation == "MemberOf") %>% pull(to)
  has_group <- length(group_ids) > 0
  performer_ids <- if (has_group) c(artist_id, group_ids) else artist_id

  performer_edges <- graph %>% activate(edges) %>%
    filter(from %in% performer_ids, relation == "PerformerOf") %>%
    as_tibble() %>%
    mutate(Performer = ifelse(from == artist_id, "Solo", "Group"))

  node_df <- graph %>% activate(nodes) %>% as_tibble() %>% mutate(row_id = row_number())

  charted_releases <- performer_edges %>%
    left_join(node_df, by = c("to" = "row_id")) %>%
    filter(type %in% c("Song", "Album"), notable == TRUE) %>%
    transmute(Title = name, Type = type, Performer, `Release Year` = as.integer(release_date), Single = single)

  albums <- charted_releases %>% filter(Type == "Album")
  singles <- charted_releases %>% filter(Type == "Song", Single == TRUE)

  album_counts <- albums %>% count(`Release Year`, Performer, name = "Count") %>% mutate(Type = "Album")
  single_counts <- singles %>% count(`Release Year`, Performer, name = "Count") %>% mutate(Type = "Song")

  all_years <- min(c(album_counts$`Release Year`, single_counts$`Release Year`), na.rm = TRUE):max(c(album_counts$`Release Year`, single_counts$`Release Year`), na.rm = TRUE)
  all_performers <- unique(charted_releases$Performer)

  album_complete <- album_counts %>% complete(`Release Year` = all_years, Performer = all_performers, Type = "Album", fill = list(Count = 0))
  single_complete <- single_counts %>% complete(`Release Year` = all_years, Performer = all_performers, Type = "Song", fill = list(Count = 0))

  song_dots <- expand.grid(`Release Year` = all_years, Performer = all_performers, stringsAsFactors = FALSE) %>%
    left_join(singles %>% count(`Release Year`, Performer, name = "Count"), by = c("Release Year", "Performer")) %>%
    mutate(Count = replace_na(Count, 0), Type = "Song")

  make_plot <- function(df, dots, performer_label, type_label) {
    line_color <- ifelse(type_label == "Song", cl$jeans, cl$jeans)
    dot_fill <- ifelse(performer_label == "Solo", cl$t_shirt, cl$t_shirt)

    ggplot(df, aes(x = `Release Year`, y = Count)) +
      geom_line(color = line_color, linewidth = 1, alpha = 0.5, linetype = "dashed") +
      geom_point(data = dots, aes(x = `Release Year`, y = Count), color = "black", fill = dot_fill, shape = 21, size = 2, inherit.aes = FALSE) +
      scale_y_continuous(limits = c(0, max(df$Count, na.rm = TRUE) + 1), expand = c(0, 0)) +
      scale_x_continuous(breaks = all_years) +
      labs(title = paste(performer_label, type_label), x = "Release Year", y = "Number of Releases") +
      theme_classic() +
      theme(
        plot.background = theme$background,
        panel.background = theme$panel,
        panel.grid.major = theme$grid,
        text = element_text(family = theme$font, size = theme$size),
        plot.title = theme$title,
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
      )
  }

  p1 <- make_plot(album_complete %>% filter(Performer == "Solo"), album_complete %>% filter(Performer == "Solo"), "Solo", "Album")
  p2 <- make_plot(single_complete %>% filter(Performer == "Solo"), song_dots %>% filter(Performer == "Solo"), "Solo", "Song")
  p3 <- make_plot(album_complete %>% filter(Performer == "Group"), album_complete %>% filter(Performer == "Group"), "Group", "Album")
  p4 <- make_plot(single_complete %>% filter(Performer == "Group"), song_dots %>% filter(Performer == "Group"), "Group", "Song")

  if (has_group) {
  (p1 | p2) / (p3 | p4)
} else {
  p1 | p2
}
}
```

### List of Oceanus Folk Artist

```{r}
#| code-fold: true
oceanus_nodes <- graph %>%
  activate(nodes) %>%
  mutate(row_id = row_number()) %>%
  filter(genre == "Oceanus Folk", `Node Type` %in% c("Song", "Album")) %>%
  pull(row_id)

oceanus_performers <- graph %>%
  activate(edges) %>%
  filter(to %in% oceanus_nodes, relation == "PerformerOf") %>%
  pull(from) %>%
  unique()

graph_with_centrality <- graph %>%
  activate(nodes) %>%
  mutate(
    degree_centrality = centrality_degree()
  )

centrality_table <- graph_with_centrality %>%
  activate(nodes) %>%
  mutate(row_id = row_number()) %>%
  filter(row_id %in% oceanus_performers, `Node Type` == "Person") %>%
  as_tibble() %>%
  select(name, `Node Type`, degree_centrality) %>%
  arrange(desc(degree_centrality))

colnames(centrality_table) <- c("Artist", "Node Type", "Connections")

centrality_table %>%
  kable(caption = "Artists Who Performed Oceanus Folk Songs or Albums")%>%
  scroll_box(height = "400px")
```

### Sailor Shift

::: {.panel-tabset .nav-pills}
#### Creative Activity

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- artist_creativity(graph,"Sailor Shift")
center <- c("Sailor Shift", result$group)
plot(
  result$graph,
  center_name = center,
  title = paste0(center[1], ": Songs and Release Years"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
release_timeline(result$works,"Sailor Shift")
```

#### Creative Contribution

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- contribution_network(graph,"Sailor Shift")
center <- c("Sailor Shift")
plot(
  result$graph,
  center_name = center,
  title = paste0("How many works ",center[1]," have contributed?"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

#### Collaboration

```{r}
#| code-fold: true
result <- artist_collab_network(graph, "Sailor Shift")
center <- c("Sailor Shift")
plot(
  result,
  center_name = center,
  title = paste0(center[1], "'s Collaboration Network"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

```{r}
#| code-fold: true

collaborator_count <- result %>%
  activate(nodes) %>%
  as_tibble() %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup"), name != "Sailor Shift") %>%
  count(`Node Type`)

collaborator_count %>% 
  kable(caption = "Number of Collaborators")
```

#### Public Recognition

[<strong>Table</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
tables <- public_recognition_table(graph, "Sailor Shift")

tables$Solo %>%
  kable(caption = "Solo Charted Releases", align = "lccc")


tables$Group %>%
  kable(caption = "Group Charted Releases", align = "lccc")
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
public_recognition_line(graph, "Sailor Shift")
```
:::

### Yang Wan

::: {.panel-tabset .nav-pills}
```{r echo = FALSE}
wan <- clean_duplicate_artist(graph,"Yang Wan")
```

#### Creative Activity

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- artist_creativity(wan, "Yang Wan")
center <- c("Yang Wan", result$group)
plot(
  result$graph,
  center_name = center,
  title = paste0(center[1], ": Songs and Release Years"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
release_timeline(result$works,"Yang Wan")
```

#### Creative Contribution

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- contribution_network(wan,"Yang Wan")
center <- c("Yang Wan")
plot(
  result$graph,
  center_name = center,
  title = paste0("How many works ",center[1]," have contributed?"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

#### Collaboration

```{r}
#| code-fold: true
result <- artist_collab_network(wan, "Yang Wan")
center <- c("Yang Wan")
plot(
  result,
  center_name = center,
  title = paste0(center[1], "'s Collaboration Network"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

```{r}
#| code-fold: true

collaborator_count <- result %>%
  activate(nodes) %>%
  as_tibble() %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup"), name != "Yang Wan") %>%
  count(`Node Type`)

collaborator_count %>% 
  kable(caption = "Number of Collaborators")
```

#### Public Recognition

[<strong>Table</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
tables <- public_recognition_table(wan, "Yang Wan")

tables$Solo %>%
  kable(caption = "Solo Charted Releases", align = "lccc")


tables$Group %>%
  kable(caption = "Group Charted Releases", align = "lccc")
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
public_recognition_line(wan, "Yang Wan")
```
:::

### Rüdiger Graf

::: {.panel-tabset .nav-pills}
```{r echo = FALSE}
graf <- clean_duplicate_artist(graph,"Rüdiger Graf")
```

#### Creative Activity

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- artist_creativity(graf, "Rüdiger Graf")
center <- c("Rüdiger Graf", result$group)
plot(
  result$graph,
  center_name = center,
  title = paste0(center[1], ": Songs and Release Years"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
release_timeline(result$works,"Rüdiger Graf")
```

#### Creative Contribution

[<strong>Network Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
result <- contribution_network(graf,"Rüdiger Graf")
center <- c("Rüdiger Graf")
plot(
  result$graph,
  center_name = center,
  title = paste0("How many works ",center[1]," have contributed?"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

#### Collaboration

```{r}
#| code-fold: true
result <- artist_collab_network(graf, "Rüdiger Graf")
center <- c("Rüdiger Graf")
plot(
  result,
  center_name = center,
  title = paste0(center[1], "'s Collaboration Network"),
  size_1 = 5,
  size_2 = 8,
  show_arrows = TRUE,
  layout = "kk"
)
```

```{r}
#| code-fold: true

collaborator_count <- result %>%
  activate(nodes) %>%
  as_tibble() %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup"), name != "Rüdiger Graf") %>%
  count(`Node Type`)

collaborator_count %>% 
  kable(caption = "Number of Collaborators")
```

#### Public Recognition

[<strong>Table</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
tables <- public_recognition_table(graf, "Rüdiger Graf")

tables$Solo %>%
  kable(caption = "Solo Charted Releases", align = "lccc")


tables$Group %>%
  kable(caption = "Group Charted Releases", align = "lccc")
```

[<strong>Line Graph</strong>]{style="color:#A94442; font-size:20px;"}

```{r}
#| code-fold: true
public_recognition_line(graf, "Rüdiger Graf")
```
:::

::: callout-tip
### Observations

-   **Creative Activity** : **Sailor Shift** built a long, steady career from 2024 to 2040, consistently releasing music, **Yang Wan** had an early start in 1994, disappeared for years, then made several strong comebacks after 2010, **Rüdiger Graf** rose quickly between 2024 and 2026, peaking fast but dropping off just as quickly a brief flash of fame that didn’t last. These distinct career patterns reveal that rising stars in Oceanus Folk begin with consistent growth.

-   **Creative Contribution**: **Sailor Shift** maintained a steady presence as a focused lyricist, **Yang Wan** contributed across multiple creative roles composer, lyricist, and producer showing strong versatility, **Rüdiger Graf** took on a mix of roles early on but lacked sustained involvement. This kind of observations suggest that rising stars often emerge through either consistent specialization on the rolse or early multi role engagement.

-   **Collaboration**: **Yang Wan** has the largest network with 76 individuals and 2 groups, showing broad influence and strong community presence, **Sailor Shift** has 40 individual and 8 group collaborators, suggesting a balanced, stable network built over time, while **Rüdiger Graf** has 25 individuals and 1 group—more limited, but notable given the shorter career span. Artists with high collaborator counts—especially early in their careers—tend to gain more exposure, expand their influence, and accelerate their growth. Thus, emerging artists who are quickly building networks are strong candidates to watch as the next rising stars.

-   **Public Recognition**: **Sailor Shift** stands out with both solo and group charted releases, showing broad reach and influence, **Yang Wan** has a strong solo-only chart record that reflects resilience and longevity, while **Rüdiger Graf** shows early momentum through recent solo chart activity, this is a key signal of rising star potential characteristics.
:::

## Question 3: The Next Rising Star of Oceanus Folk

```{r}
#| code-fold: true
nodes <- graph %>% 
  activate(nodes) %>% 
  mutate(row_id = row_number()) %>% 
  as_tibble()

edges <- graph %>% 
  activate(edges) %>% 
  as_tibble()

oceanus_nodes <- nodes %>%
  filter(genre == "Oceanus Folk", `Node Type` %in% c("Song", "Album")) %>%
  pull(row_id)

oceanus_performers <- edges %>%
  filter(to %in% oceanus_nodes, relation == "PerformerOf") %>%
  pull(from) %>% unique()

collabs <- edges %>%
  filter(relation %in% c("ComposerOf", "LyricistOf", "ProducerOf"),
         from %in% oceanus_performers) %>%
  group_by(from) %>%
  summarise(Collabs = n_distinct(to), Creative = n(), .groups = "drop")

release_info <- edges %>%
  filter(from %in% oceanus_performers, relation == "PerformerOf", to %in% oceanus_nodes) %>%
  left_join(nodes %>% select(row_id, release_date, notable), by = c("to" = "row_id")) %>%
  mutate(release_year = as.integer(release_date)) %>%
  filter(!is.na(release_year)) %>%
  left_join(nodes %>% select(row_id, name, `Node Type`) %>%
              rename(artist_id = row_id, artist_name = name),
            by = c("from" = "artist_id")) %>%
  filter(`Node Type` %in% c("Person", "MusicalGroup"))

current_year <- 2040

table <- release_info %>%
  group_by(artist_name, from) %>%
  summarise(
    First = min(release_year, na.rm = TRUE),
    Total = n(),
    Active = n_distinct(release_year),
    Charted = sum(notable == TRUE, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(First >= 2030, Total >= 3) %>%
  left_join(collabs, by = "from") %>%
  mutate(
    Inactivity = (current_year - First + 1) - Active,
    Collabs = replace_na(Collabs, 0),
    Creative = replace_na(Creative, 0),
    Freshness = exp(-Inactivity * 0.4),
    ChartedRatio = Charted / Total,
    Score = round(((Total * 1.0) + (ChartedRatio * 15) + (Collabs * 1.0) + (Creative * 1.2)) * Freshness, 2)
  ) %>%
  arrange(desc(Score))

kable(table, col.names = c("Artist", "ID", "First Release", "Total Works", "Active Years",
                           "Charted", "Collabs", "Creative", "Inactivity", "Freshness",
                           "Charted Ratio", "Rising Star Score"))
```

::: callout-tip
### Conclusions

Based on the computed metrics including total works, charted ratio, collaboration count, creative contributions, and a freshness score that penalizes inactivity the predicted rising stars in the Oceanus Folk genre are **The Brine Choir, Selkie’s Hollow, and Copper Canyon**.
:::

::: callout-note
**What Makes a Rising Star**:

The model goes beyond just popularity. It also looks at:

-   Creative Activity: Regular releases, like Sailor Shift’s, suggest steady growth.
-   Creative Contribution: Versatile creators like Yang Wan, or focused ones like Sailor Shift, both show strong artistic identity.
-   Collaboration: Large, active networks—especially built early—are often signs of rising stars.
-   Public Recognition: Charted songs help, but they aren’t everything. Sailor Shift, for example, may not have a perfect chart ratio, but her consistency and connections still make her stand out.

**Rising Star Score** :

The score combines multiple aspects of an artist’s career to highlight those with strong future potential.

-   Total Works reflects how productive an artist has been.
-   Charted Ratio emphasizes public recognition impact matters more than volume.
-   Collaboration Count and Creative Contributions show how engaged and versatile an artist is behind the scenes.
-   All of these are adjusted by Freshness, which penalizes long inactivity artists who started early but went quiet get lower scores.

**Additional Notes**: 

- The current year is assumed to be 2040. 
- We filter artists whose works have release years between 2030 and 2040, and only artists with at least 3 releases during this period are included.This filtering helps exclude inactive or minimally active artists.
:::

# References

[**VAST Challenge Kickstarter 2**](https://isss608-ay2023-24apr.netlify.app/vast/kickstarter2)
